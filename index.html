<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<title>Juego nivel 1</title>
<style>
  html,body{margin:0;overflow:hidden;background:#000}
  #renderCanvas{width:100%;height:100%}
  #joystick-container{position:absolute;bottom:30px;left:30px;width:150px;height:150px;z-index:10}
  .button{position:absolute;bottom:30px;width:60px;height:60px;background:rgba(255,255,255,0.2);border-radius:50%;pointer-events:auto;}
  #btnAttack{right:100px} #btnMagic{right:180px}
  #healthBarContainer{position:absolute;top:10px;left:10px;width:200px;height:20px;background:#444;border:1px solid #fff}
  #healthBar{height:100%;width:50%;background:#0f0;transition:width .3s}
  #pickupMsg{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);font-weight:bold;font-size:22px;opacity:0;pointer-events:none;transition:opacity .3s; text-shadow: 2px 2px 4px rgba(0,0,0,0.5);} /* Sombra para mejor visibilidad */
</style>
</head>
<body>
<canvas id="renderCanvas"></canvas>
<div id="joystick-container"></div>
<div id="healthBarContainer"><div id="healthBar"></div></div>
<div id="pickupMsg"></div>
<div class="button" id="btnAttack"></div>
<div class="button" id="btnMagic"></div>

<script src="https://cdn.jsdelivr.net/npm/nipplejs@0.9.0/dist/nipplejs.min.js"></script>
<script src="https://cdn.babylonjs.com/babylon.js"></script>
<script src="https://cdn.babylonjs.com/loaders/babylon.glTF2FileLoader.min.js"></script>

<script>
const canvas = document.getElementById("renderCanvas");
const engine = new BABYLON.Engine(canvas,true);
const scene = new BABYLON.Scene(engine);
scene.preventDefaultOnDoubleClick = false;
scene.collisionsEnabled = true;
scene.gravity = new BABYLON.Vector3(0,-9.81,0);

const camera = new BABYLON.FreeCamera("cam", new BABYLON.Vector3(1,1,-5), scene);
camera.attachControl(canvas,true);
camera.inputs.attached.mousewheel?.detachControl(canvas);
camera.checkCollisions = true;
camera.applyGravity = true;
camera.ellipsoid = new BABYLON.Vector3(1,1,1);
camera.maxStepHeight = 1;

new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0,1,0), scene);

let vidaJugador = 100; // La vida inicial del jugador es 100
const healthBar = document.getElementById("healthBar");
const pickupMsg = document.getElementById("pickupMsg");

function updateHealthBar(){
  healthBar.style.width = Math.min(vidaJugador,100) + "%";
  if(vidaJugador <= 0){ alert("Has perdido"); location.reload(); }
}
updateHealthBar();

function showPickup(text, color = "#0ff"){ // Función mejorada para aceptar color
  pickupMsg.textContent = text;
  pickupMsg.style.color = color;
  pickupMsg.style.opacity = 1;
  setTimeout(()=> pickupMsg.style.opacity = 0, 1000); // 1 segundo de duración
}

let joyX=0, joyY=0;
const joystick = nipplejs.create({
  zone: document.getElementById("joystick-container"),
  mode: "static", position:{left:"75px",bottom:"75px"},
  size:120, color:"white"
});
joystick.on("move", (_,d)=>{ joyX=d.vector.x; joyY=d.vector.y; });
joystick.on("end", ()=>{ joyX=0; joyY=0; });

const config = { attackRange:5, playerAttackDamage:20, enemyDamageRatio: 0.01 }; // El enemigo quita 1% de la vida actual

const enemies = []; // Ahora solo almacenamos las referencias a los objetos de enemigo
const itemMeshes = []; // Almacenamos {mesh, light, data} para los ítems
let portalMesh=null, hasKey=false; // hasKey controla si la llave ha sido recogida

// Carga del mapa
BABYLON.SceneLoader.Append("", "mapa.glb", scene, ()=>{
  scene.meshes.forEach(m=>m.checkCollisions=true);
  camera.position = new BABYLON.Vector3(1,1,-5);
  initEntities();
});

function initEntities(){
  [{x:2,z:2},{x:-3,z:1},{x:5,z:-4}].forEach(e=>enemies.push(createEnemy(e.x,e.z)));
  
  const texH = new BABYLON.StandardMaterial("healthTex",scene);
  texH.diffuseTexture = new BABYLON.Texture("https://i.ibb.co/Xr1rftKg/1b452991-913b-4dbe-8f25-43f7108d1d70.png",scene);
  createItem(1,0,"health",texH);
  
  const texK = new BABYLON.StandardMaterial("keyTex",scene);
  texK.diffuseTexture = new BABYLON.Texture("https://i.ibb.co/HpKK2xwJ/1000012289-removebg-preview.png",scene);
  createItem(-1,3,"key",texK);
  
  portalMesh = BABYLON.MeshBuilder.CreateCylinder("portal",{height:0.1,diameter:1.5},scene);
  portalMesh.position = new BABYLON.Vector3(4,0.05,4);
  portalMesh.checkCollisions = false; // Importante: el portal NO tiene colisión
  const pMat = new BABYLON.StandardMaterial("portalMat",scene);
  pMat.emissiveColor = new BABYLON.Color3(0.5,0,1);pMat.alpha=0.7;
  portalMesh.material = pMat;
}

function createEnemy(x,z){
  const enemy = {mesh:null, health:50, attackCooldown: 0}; // Añadimos cooldown para el ataque
  BABYLON.SceneLoader.ImportMeshAsync(null,"","bat.glb",scene).then(r=>{
    const m=r.meshes[0];
    m.position=new BABYLON.Vector3(x,1.8,z);
    m.scaling=new BABYLON.Vector3(0.07,0.07,0.07);
    m.checkCollisions=true;
    enemy.mesh=m;
  });
  return enemy;
}

function createItem(x,z,type,mat){
  const m=BABYLON.MeshBuilder.CreatePlane(type,{width:0.3,height:0.3},scene);
  m.billboardMode=BABYLON.Mesh.BILLBOARDMODE_ALL;
  m.position=new BABYLON.Vector3(x,0.5,z);
  m.material=mat;
  m.checkCollisions = false; // Importante: los items NO tienen colisión
  const lt=new BABYLON.PointLight("",m.position,scene);
  itemMeshes.push({mesh:m,light:lt,data:{x,z,type}});
}

function checkItemCollisions(){
  for(let i=itemMeshes.length-1;i>=0;i--){
    const obj=itemMeshes[i];
    const dist=BABYLON.Vector3.Distance(camera.position,obj.mesh.position);
    if(dist<1){ // Si la distancia es menor a 1 unidad, se considera recogido
      collectItem(obj.data);
      obj.mesh.dispose(); obj.light.dispose(); itemMeshes.splice(i,1);
    }
  }
}

function collectItem(item){
  if(item.type==="health"){
    vidaJugador=Math.min(vidaJugador+25,100);
    updateHealthBar(); 
    showPickup("Has recogido una pócima de salud", "#00ff00"); // Mensaje verde para salud
  } else if(item.type==="key"){
    hasKey=true; 
    portalMesh.material.emissiveColor=new BABYLON.Color3(0.8,0.2,1); // Cambia el color del portal al tener la llave
    portalMesh.material.alpha=0.8;
    showPickup("Has recogido una llave", "#ffff00"); // Mensaje amarillo para llave
  }
}

function playerAttack() {
      // Lanzar un rayo en dirección donde mira la cámara
      const ray = new BABYLON.Ray(
        camera.position, 
        camera.getTarget().subtract(camera.position).normalize(), 
        config.attackRange
      );
      
      // Efecto visual - flash
      const flash = new BABYLON.PointLight("attackFlash", 
        camera.position.add(camera.getTarget().subtract(camera.position).normalize()), 
        scene);
      flash.diffuse = new BABYLON.Color3(1, 0.5, 0);
      flash.range = 10;
      flash.intensity = 1;
      
      setTimeout(() => flash.dispose(), 100);
      
      // Verificar impacto en enemigos
      enemies.forEach(enemy => {
        if (enemy.mesh && enemy.health > 0) {
          const pickResult = scene.pickWithRay(ray, (mesh) => mesh === enemy.mesh);
          if (pickResult.hit) {
            enemy.health -= config.playerAttackDamage;
            showPickup(`¡Enemigo golpeado! Vida restante: ${enemy.health}`, "#ff0000"); // Mensaje rojo al golpear

            if (enemy.health <= 0) {
              showPickup("¡Enemigo eliminado!", "#f00"); // Mensaje rojo al eliminar
              // Animación de muerte
              const duration = 30;
              const shrinkAnimation = new BABYLON.Animation("enemyShrinkAnimation", "scaling", 30, BABYLON.Animation.ANIMATIONTYPE_VECTOR3, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
              const sinkAnimation = new BABYLON.Animation("enemySinkAnimation", "position.y", 30, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
              const scaleKeys = [
                { frame: 0, value: enemy.mesh.scaling.clone() },
                { frame: duration, value: new BABYLON.Vector3(0.01, 0.01, 0.01) } // Se encoge a un tamaño muy pequeño
              ];
              const positionKeys = [
                { frame: 0, value: enemy.mesh.position.y },
                { frame: duration, value: -1 } // Se hunde por debajo del suelo
              ];
              shrinkAnimation.setKeys(scaleKeys);
              sinkAnimation.setKeys(positionKeys);
              enemy.mesh.animations = [shrinkAnimation, sinkAnimation];
              const animatable = scene.beginAnimation(enemy.mesh, 0, duration, false);
              animatable.onAnimationEnd = function() {
                enemy.mesh.dispose();
                enemies.splice(enemies.indexOf(enemy), 1); // Elimina el enemigo de la lista
              };
            }
          }
        }
      });
}

function castMagic(){
  const magicFlash=new BABYLON.HemisphericLight("magicFlash",camera.position,scene);
  magicFlash.diffuse=new BABYLON.Color3(0.2,0.4,1);
  magicFlash.groundColor=new BABYLON.Color3(0.1,0.2,0.5);
  magicFlash.intensity=20;
  setTimeout(()=>magicFlash.dispose(),200);

  enemies.forEach(enemy=>{
    if(enemy.mesh && enemy.health > 0){
      const dist=BABYLON.Vector3.Distance(camera.position,enemy.mesh.position);
      if(dist<=config.attackRange*1.5){ // Mayor rango para magia
        enemy.health-=config.playerAttackDamage;
        showPickup(`¡Enemigo alcanzado por magia! Vida restante: ${enemy.health}`, "#0000ff"); // Mensaje azul

        if(enemy.health<=0) {
          showPickup("¡Enemigo eliminado!", "#f00");
          // Animación de muerte (similar a playerAttack)
          const duration = 30;
          const shrinkAnimation = new BABYLON.Animation("enemyShrinkAnimation", "scaling", 30, BABYLON.Animation.ANIMATIONTYPE_VECTOR3, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
          const sinkAnimation = new BABYLON.Animation("enemySinkAnimation", "position.y", 30, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
          const scaleKeys = [
            { frame: 0, value: enemy.mesh.scaling.clone() },
            { frame: duration, value: new BABYLON.Vector3(0.01, 0.01, 0.01) }
          ];
          const positionKeys = [
            { frame: 0, value: enemy.mesh.position.y },
            { frame: duration, value: -1 }
          ];
          shrinkAnimation.setKeys(scaleKeys);
          sinkAnimation.setKeys(positionKeys);
          enemy.mesh.animations = [shrinkAnimation, sinkAnimation];
          const animatable = scene.beginAnimation(enemy.mesh, 0, duration, false);
          animatable.onAnimationEnd = function() {
            enemy.mesh.dispose();
            enemies.splice(enemies.indexOf(enemy), 1);
          };
        }
      }
    }
  });
}

document.getElementById("btnAttack").onclick = playerAttack;
document.getElementById("btnMagic").onclick = castMagic;

engine.runRenderLoop(()=>{
  const f=camera.getDirection(BABYLON.Axis.Z), r=camera.getDirection(BABYLON.Axis.X);
  camera.cameraDirection = BABYLON.Vector3.Zero()
    .addInPlace(f.scale(joyY*0.1))
    .addInPlace(r.scale(joyX*0.1));

  enemies.forEach(enemy=>{
    if(enemy.mesh && enemy.health > 0){ // Solo si el enemigo está vivo
      const dir = camera.position.subtract(enemy.mesh.position);
      const dist=dir.length();
      if(dist<30 && dist>1.5){ // Si el jugador está en rango y no demasiado cerca, el enemigo se mueve
        enemy.mesh.moveWithCollisions(dir.normalize().scale(0.06));
      } else if (dist <= 1.5 && enemy.attackCooldown <= 0) { // Si el jugador está muy cerca, el enemigo ataca
        vidaJugador -= Math.max(1, Math.round(vidaJugador * config.enemyDamageRatio)); // El enemigo quita un porcentaje de la vida actual
        updateHealthBar();
        showPickup("¡Has sido atacado!", "#ff0000"); // Mensaje rojo al ser atacado
        enemy.attackCooldown = 60; // Cooldown de 1 segundo (asumiendo 60 FPS)
      }
      if (enemy.attackCooldown > 0) {
        enemy.attackCooldown--; // Reduce el cooldown
      }
    }
  });

  checkItemCollisions();

  if(portalMesh){
    portalMesh.rotation.y += 0.01;
    const distToPortal = BABYLON.Vector3.Distance(camera.position,portalMesh.position);
    if(distToPortal < 1.5){ // Si el jugador está cerca del portal
      if(hasKey){
        window.location.href = "nivel2.html"; // Redirige si tiene la llave
      } else {
        showPickup("Te hace falta la llave para pasar", "#ff5500"); // Mensaje naranja si no tiene la llave
      }
    }
  }

  scene.render();
});

window.addEventListener("resize",()=>engine.resize());
</script>
</body>
</html>
