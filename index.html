<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<title>Juego nivel 1</title>
<style>
  html,body{margin:0;overflow:hidden;background:#000}
  #renderCanvas{width:100%;height:100%}
  #joystick-container{position:absolute;bottom:30px;left:30px;width:150px;height:150px;z-index:10}
  .button{position:absolute;bottom:30px;width:60px;height:60px;background:rgba(255,255,255,0.2);border-radius:50%;pointer-events:auto;}
  #btnAttack{right:100px} #btnMagic{right:180px}
  #healthBarContainer{position:absolute;top:10px;left:10px;width:200px;height:20px;background:#444;border:1px solid #fff}
  #healthBar{height:100%;width:50%;background:#0f0;transition:width .3s}
  #pickupMsg{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);color:#0ff;font-weight:bold;font-size:22px;opacity:0;pointer-events:none;transition:opacity .3s; text-shadow: 2px 2px 4px rgba(0,0,0,0.5);} /* Sombra para mejor visibilidad */
</style>
</head>
<body>
<canvas id="renderCanvas"></canvas>
<div id="joystick-container"></div>
<div id="healthBarContainer"><div id="healthBar"></div></div>
<div id="pickupMsg"></div>
<div class="button" id="btnAttack"></div>
<div class="button" id="btnMagic"></div>

<script src="https://cdn.jsdelivr.net/npm/nipplejs@0.9.0/dist/nipplejs.min.js"></script>
<script src="https://cdn.babylonjs.com/babylon.js"></script>
<script src="https://cdn.babylonjs.com/loaders/babylon.glTF2FileLoader.min.js"></script>

<script>
const canvas = document.getElementById("renderCanvas");
const engine = new BABYLON.Engine(canvas, true);
const scene = new BABYLON.Scene(engine);
scene.preventDefaultOnDoubleClick = false;
scene.collisionsEnabled = true;
scene.gravity = new BABYLON.Vector3(0, -9.81, 0);

const camera = new BABYLON.FreeCamera("cam", new BABYLON.Vector3(1, 1, -5), scene);
camera.attachControl(canvas, true);
camera.inputs.attached.mousewheel?.detachControl(canvas);
camera.checkCollisions = true;
camera.applyGravity = true;
camera.ellipsoid = new BABYLON.Vector3(1, 1, 1);
camera.maxStepHeight = 1;

new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);

let vidaJugador = 100; // Inicia con 100 de vida
const healthBar = document.getElementById("healthBar");
const pickupMsg = document.getElementById("pickupMsg");

function updateHealthBar() {
  healthBar.style.width = Math.min(vidaJugador, 100) + "%";
  if (vidaJugador <= 0) {
    alert("Has perdido");
    location.reload();
  }
}
updateHealthBar();

function showPickup(text, color = "#0ff") { // Añadido parámetro de color
  pickupMsg.textContent = text;
  pickupMsg.style.color = color; // Asigna el color
  pickupMsg.style.opacity = 1;
  setTimeout(() => pickupMsg.style.opacity = 0, 1000); // 1 segundo de duración
}

let joyX = 0, joyY = 0;
const joystick = nipplejs.create({
  zone: document.getElementById("joystick-container"),
  mode: "static", position: { left: "75px", bottom: "75px" },
  size: 120, color: "white"
});
joystick.on("move", (_, d) => { joyX = d.vector.x; joyY = d.vector.y; });
joystick.on("end", () => { joyX = 0; joyY = 0; });

const config = { attackRange: 5, playerAttackDamage: 20, enemyAttackDamageRatio: 0.01 }; // Enemy damage is 1% of player's max health

const enemies = [];
const itemMeshes = []; // Guarda las referencias a los meshes y datos de los ítems
let portalMesh = null, hasKey = false; // portalActive no es necesario, se controla con hasKey

// Carga del mapa
BABYLON.SceneLoader.Append("", "mapa.glb", scene, () => {
  scene.meshes.forEach(m => m.checkCollisions = true);
  camera.position = new BABYLON.Vector3(1, 1, -5);
  initEntities();
});

function initEntities() {
  // Crear enemigos
  [{ x: 2, z: 2 }, { x: -3, z: 1 }, { x: 5, z: -4 }].forEach(e => enemies.push(createEnemy(e.x, e.z)));

  // Textura para la pócima de salud
  const texH = new BABYLON.StandardMaterial("healthTex", scene);
  texH.diffuseTexture = new BABYLON.Texture("https://i.ibb.co/Xr1rftKg/1b452991-913b-4dbe-8f25-43f7108d1d70.png", scene);
  createItem(1, 0, "health", texH);

  // Textura para la llave
  const texK = new BABYLON.StandardMaterial("keyTex", scene);
  texK.diffuseTexture = new BABYLON.Texture("https://i.ibb.co/HpKK2xwJ/1000012289-removebg-preview.png", scene);
  createItem(-1, 3, "key", texK);

  // Portal
  portalMesh = BABYLON.MeshBuilder.CreateCylinder("portal", { height: 0.1, diameter: 1.5 }, scene);
  portalMesh.position = new BABYLON.Vector3(4, 0.05, 4);
  portalMesh.checkCollisions = false; // El portal no tiene colisiones para la llave
  const pMat = new BABYLON.StandardMaterial("portalMat", scene);
  pMat.emissiveColor = new BABYLON.Color3(0.5, 0, 1);
  pMat.alpha = 0.7;
  portalMesh.material = pMat;
}

function createEnemy(x, z) {
  const enemy = { mesh: null, health: 50, attackCooldown: 0 };
  BABYLON.SceneLoader.ImportMeshAsync(null, "", "bat.glb", scene).then(r => {
    const m = r.meshes[0];
    m.position = new BABYLON.Vector3(x, 1.8, z);
    m.scaling = new BABYLON.Vector3(0.07, 0.07, 0.07);
    m.checkCollisions = true;
    enemy.mesh = m;
  });
  return enemy;
}

function createItem(x, z, type, mat) {
  const m = BABYLON.MeshBuilder.CreatePlane(type, { width: 0.3, height: 0.3 }, scene);
  m.billboardMode = BABYLON.Mesh.BILLBOARDMODE_ALL;
  m.position = new BABYLON.Vector3(x, 0.5, z);
  m.material = mat;
  m.checkCollisions = false; // Los items no tienen colisiones, solo se detectan por distancia
  const lt = new BABYLON.PointLight("", m.position, scene);
  itemMeshes.push({ mesh: m, light: lt, data: { x, z, type } });
}

function checkItemCollisions() {
  for (let i = itemMeshes.length - 1; i >= 0; i--) {
    const obj = itemMeshes[i];
    const dist = BABYLON.Vector3.Distance(camera.position, obj.mesh.position);
    if (dist < 1) { // Distancia de recogida
      collectItem(obj.data);
      obj.mesh.dispose();
      obj.light.dispose();
      itemMeshes.splice(i, 1);
    }
  }
}

function collectItem(item) {
  if (item.type === "health") {
    vidaJugador = Math.min(vidaJugador + 25, 100);
    updateHealthBar();
    showPickup("Has recogido una pócima de salud", "#00ff00"); // Verde
  } else if (item.type === "key") {
    hasKey = true;
    portalMesh.material.emissiveColor = new BABYLON.Color3(0.8, 0.2, 1); // Cambiar color del portal
    portalMesh.material.alpha = 0.8;
    showPickup("Has recogido una llave", "#ffff00"); // Amarillo
  }
}

function playerAttack() {
  const ray = new BABYLON.Ray(
    camera.position,
    camera.getTarget().subtract(camera.position).normalize(),
    config.attackRange
  );

  const flash = new BABYLON.PointLight("attackFlash",
    camera.position.add(camera.getTarget().subtract(camera.position).normalize()),
    scene);
  flash.diffuse = new BABYLON.Color3(1, 0.5, 0);
  flash.range = 10;
  flash.intensity = 1;
  setTimeout(() => flash.dispose(), 100);

  enemies.forEach(enemy => {
    if (enemy.mesh && enemy.health > 0) {
      const pickResult = scene.pickWithRay(ray, (mesh) => mesh === enemy.mesh);
      if (pickResult.hit) {
        enemy.health -= config.playerAttackDamage;
        showPickup(`¡Enemigo golpeado! Vida restante: ${enemy.health}`, "#ff0000");

        if (enemy.health <= 0) {
          showPickup("¡Enemigo eliminado!", "#f00");
          // Animación de muerte
          const duration = 30;
          const shrinkAnimation = new BABYLON.Animation("enemyShrinkAnimation", "scaling", 30, BABYLON.Animation.ANIMATIONTYPE_VECTOR3, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
          const sinkAnimation = new BABYLON.Animation("enemySinkAnimation", "position.y", 30, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
          const scaleKeys = [
            { frame: 0, value: enemy.mesh.scaling.clone() },
            { frame: duration, value: new BABYLON.Vector3(0.01, 0.01, 0.01) }
          ];
          const positionKeys = [
            { frame: 0, value: enemy.mesh.position.y },
            { frame: duration, value: -1 }
          ];
          shrinkAnimation.setKeys(scaleKeys);
          sinkAnimation.setKeys(positionKeys);
          enemy.mesh.animations = [shrinkAnimation, sinkAnimation];
          const animatable = scene.beginAnimation(enemy.mesh, 0, duration, false);
          animatable.onAnimationEnd = function () {
            enemy.mesh.dispose();
            enemies.splice(enemies.indexOf(enemy), 1);
          };
        }
      }
    }
  });
}

function castMagic() {
  const magicFlash = new BABYLON.HemisphericLight("magicFlash", camera.position, scene);
  magicFlash.diffuse = new BABYLON.Color3(0.2, 0.4, 1);
  magicFlash.groundColor = new BABYLON.Color3(0.1, 0.2, 0.5);
  magicFlash.intensity = 20;
  setTimeout(() => magicFlash.dispose(), 200);

  enemies.forEach(enemy => {
    if (enemy.mesh && enemy.health > 0) {
      const dist = BABYLON.Vector3.Distance(camera.position, enemy.mesh.position);
      if (dist <= config.attackRange * 1.5) { // Área de efecto más grande para magia
        enemy.health -= config.playerAttackDamage;
        showPickup(`¡Enemigo alcanzado por magia! Vida restante: ${enemy.health}`, "#0000ff");

        if (enemy.health <= 0) {
          showPickup("¡Enemigo eliminado!", "#f00");
          // Animación de muerte (similar a playerAttack)
          const duration = 30;
          const shrinkAnimation = new BABYLON.Animation("enemyShrinkAnimation", "scaling", 30, BABYLON.Animation.ANIMATIONTYPE_VECTOR3, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
          const sinkAnimation = new BABYLON.Animation("enemySinkAnimation", "position.y", 30, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
          const scaleKeys = [
            { frame: 0, value: enemy.mesh.scaling.clone() },
            { frame: duration, value: new BABYLON.Vector3(0.01, 0.01, 0.01) }
          ];
          const positionKeys = [
            { frame: 0, value: enemy.mesh.position.y },
            { frame: duration, value: -1 }
          ];
          shrinkAnimation.setKeys(scaleKeys);
          sinkAnimation.setKeys(positionKeys);
          enemy.mesh.animations = [shrinkAnimation, sinkAnimation];
          const animatable = scene.beginAnimation(enemy.mesh, 0, duration, false);
          animatable.onAnimationEnd = function () {
            enemy.mesh.dispose();
            enemies.splice(enemies.indexOf(enemy), 1);
          };
        }
      }
    }
  });
}

document.getElementById("btnAttack").onclick = playerAttack;
document.getElementById("btnMagic").onclick = castMagic;

engine.runRenderLoop(() => {
  const f = camera.getDirection(BABYLON.Axis.Z);
  const r = camera.getDirection(BABYLON.Axis.X);
  camera.cameraDirection = BABYLON.Vector3.Zero()
    .addInPlace(f.scale(joyY * 0.1))
    .addInPlace(r.scale(joyX * 0.1));

  enemies.forEach(enemy => {
    if (enemy.mesh && enemy.health > 0) {
      const dir = camera.position.subtract(enemy.mesh.position);
      const dist = dir.length();
      if (dist < 30 && dist > 1) { // Rango de seguimiento
        enemy.mesh.moveWithCollisions(dir.normalize().scale(0.06));
      }
      // Ataque del enemigo
      if (dist < 1.5 && enemy.attackCooldown <= 0) { // Si el jugador está cerca y no está en cooldown
        vidaJugador -= Math.max(1, Math.round(vidaJugador * config.enemyAttackDamageRatio)); // Daño basado en un porcentaje de la vida actual
        updateHealthBar();
        showPickup("¡Has sido atacado!", "#ff0000"); // Rojo
        enemy.attackCooldown = 60; // Cooldown de ataque (ej: 60 frames = 1 segundo a 60 FPS)
      }
      if (enemy.attackCooldown > 0) {
        enemy.attackCooldown--;
      }
    }
  });

  checkItemCollisions();

  if (portalMesh) {
    portalMesh.rotation.y += 0.01;
    const distToPortal = BABYLON.Vector3.Distance(camera.position, portalMesh.position);
    if (distToPortal < 1.5) { // Distancia para interactuar con el portal
      if (hasKey) {
        window.location.href = "nivel2.html";
      } else {
        showPickup("Te hace falta la llave para pasar", "#ff5500"); // Naranja
      }
    }
  }

  scene.render();
});

window.addEventListener("resize", () => engine.resize());
</script>
</body>
</html>
