<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<title>Juego nivel 1</title>
<style>
  html, body { margin: 0; overflow: hidden; background: #000 }
  #renderCanvas { width: 100%; height: 100% }
  #joystick-container { position: absolute; bottom: 30px; left: 30px; width: 150px; height: 150px; z-index: 10 }
  .button { position: absolute; bottom: 30px; width: 60px; height: 60px; background: rgba(255,255,255,0.2); border-radius: 50%; pointer-events: auto; }
  #btnAttack { right: 100px } 
  #btnMagic { right: 180px }
  #healthBarContainer { position: absolute; top: 10px; left: 10px; width: 200px; height: 20px; background: #444; border: 1px solid #fff }
  #healthBar { height: 100%; width: 50%; background: #0f0; transition: width .3s }
  #pickupMsg { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #0ff; font-weight: bold; font-size: 22px; opacity: 0; pointer-events: none; transition: opacity .3s; }
  #inventory { position: absolute; top: 10px; right: 10px; color: white; font-family: Arial; }
</style>
</head>
<body>
<canvas id="renderCanvas"></canvas>
<div id="joystick-container"></div>
<div id="healthBarContainer"><div id="healthBar"></div></div>
<div id="inventory">Llave: ❌</div>
<div id="pickupMsg"></div>
<div class="button" id="btnAttack"></div>
<div class="button" id="btnMagic"></div>

<script src="https://cdn.jsdelivr.net/npm/nipplejs@0.9.0/dist/nipplejs.min.js"></script>
<script src="https://cdn.babylonjs.com/babylon.js"></script>
<script src="https://cdn.babylonjs.com/loaders/babylon.glTF2FileLoader.min.js"></script>

<script>
// Configuración básica
const canvas = document.getElementById("renderCanvas");
const engine = new BABYLON.Engine(canvas, true);
const scene = new BABYLON.Scene(engine);
scene.gravity = new BABYLON.Vector3(0, -9.81, 0);
scene.collisionsEnabled = true;

// Cámara
const camera = new BABYLON.FreeCamera("camera", new BABYLON.Vector3(0, 1.5, -5), scene);
camera.attachControl(canvas, true);
camera.checkCollisions = true;
camera.applyGravity = true;
camera.ellipsoid = new BABYLON.Vector3(0.5, 1, 0.5);

// Luz
new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);

// Variables del juego
let vidaJugador = 50;
const healthBar = document.getElementById("healthBar");
const pickupMsg = document.getElementById("pickupMsg");
const inventoryDisplay = document.getElementById("inventory");

// Sistema de inventario
const inventory = {
  key: false,
  updateDisplay: function() {
    inventoryDisplay.innerHTML = `Llave: ${this.key ? "✓" : "❌"}`;
  }
};

// Actualizar barra de salud
function updateHealthBar() {
  const percentage = Math.min(vidaJugador, 100);
  healthBar.style.width = percentage + "%";
  healthBar.style.background = percentage > 50 ? "#0f0" : percentage > 20 ? "#ff0" : "#f00";
  if (vidaJugador <= 0) {
    alert("¡Has perdido!");
    location.reload();
  }
}

// Mostrar mensaje de recolección
function showPickup(text) {
  pickupMsg.textContent = text;
  pickupMsg.style.opacity = 1;
  setTimeout(() => pickupMsg.style.opacity = 0, 1000);
}

// Joystick
let joyX = 0, joyY = 0;
const joystick = nipplejs.create({
  zone: document.getElementById("joystick-container"),
  mode: "static",
  position: { left: "75px", bottom: "75px" },
  size: 120,
  color: "white"
});
joystick.on("move", (_, data) => { joyX = data.vector.x; joyY = data.vector.y; });
joystick.on("end", () => { joyX = 0; joyY = 0; });

// Configuración de ataque
const config = {
  attackRange: 3,
  playerAttackDamage: 20
};

// Elementos del juego
const enemies = [];
const items = [];
let portal = null;

// Cargar mapa y modelos
BABYLON.SceneLoader.Append("", "mapa.glb", scene, () => {
  scene.meshes.forEach(mesh => {
    if (mesh.name.toLowerCase().includes("ground")) {
      mesh.checkCollisions = true;
      mesh.receiveShadows = true;
    }
  });
  
  initGameElements();
});

// Inicializar elementos del juego
function initGameElements() {
  // Crear enemigos
  createEnemy(2, 0);
  createEnemy(-2, 2);
  createEnemy(3, -3);

  // Crear items
  createHealthItem(1, 0);
  createKeyItem(-1, 3);
  
  // Crear portal
  createPortal(4, 0, 4);
}

// Función para crear enemigos
function createEnemy(x, z) {
  BABYLON.SceneLoader.ImportMeshAsync(null, "", "bat.glb", scene).then(result => {
    const enemyMesh = result.meshes[0];
    enemyMesh.position = new BABYLON.Vector3(x, 0, z);
    enemyMesh.scaling = new BABYLON.Vector3(0.1, 0.1, 0.1);
    enemyMesh.checkCollisions = true;
    
    enemies.push({
      mesh: enemyMesh,
      health: 50,
      speed: 0.03,
      damage: 10
    });
  });
}

// Función para crear item de salud
function createHealthItem(x, z) {
  const healthItem = BABYLON.MeshBuilder.CreatePlane("health", { width: 0.5, height: 0.5 }, scene);
  healthItem.position = new BABYLON.Vector3(x, 0.5, z);
  healthItem.billboardMode = BABYLON.Mesh.BILLBOARDMODE_ALL;
  
  const healthMat = new BABYLON.StandardMaterial("healthMat", scene);
  healthMat.diffuseTexture = new BABYLON.Texture("https://i.ibb.co/Xr1rftK/1b452991-913b-4dbe-8f25-43f7108d1d70.png", scene);
  healthMat.emissiveColor = new BABYLON.Color3(1, 0.2, 0.2);
  healthItem.material = healthMat;
  
  items.push({
    mesh: healthItem,
    type: "health",
    value: 25
  });
}

// Función para crear llave
function createKeyItem(x, z) {
  const keyItem = BABYLON.MeshBuilder.CreatePlane("key", { width: 0.5, height: 0.5 }, scene);
  keyItem.position = new BABYLON.Vector3(x, 0.5, z);
  keyItem.billboardMode = BABYLON.Mesh.BILLBOARDMODE_ALL;
  
  const keyMat = new BABYLON.StandardMaterial("keyMat", scene);
  keyMat.diffuseTexture = new BABYLON.Texture("https://i.ibb.co/HpKK2xJ/1000012289-removebg-preview.png", scene);
  keyMat.emissiveColor = new BABYLON.Color3(1, 1, 0);
  keyItem.material = keyMat;
  
  items.push({
    mesh: keyItem,
    type: "key"
  });
}

// Función para crear portal
function createPortal(x, y, z) {
  portal = BABYLON.MeshBuilder.CreateCylinder("portal", { height: 0.1, diameter: 1.5 }, scene);
  portal.position = new BABYLON.Vector3(x, y, z);
  
  const portalMat = new BABYLON.StandardMaterial("portalMat", scene);
  portalMat.emissiveColor = new BABYLON.Color3(0.5, 0, 1);
  portalMat.alpha = 0.5;
  portal.material = portalMat;
  portal.isPickable = false;
}

// Verificar colisiones con items
function checkItemCollisions() {
  for (let i = items.length - 1; i >= 0; i--) {
    const item = items[i];
    const distance = BABYLON.Vector3.Distance(camera.position, item.mesh.position);
    
    if (distance < 1) {
      if (item.type === "health") {
        vidaJugador = Math.min(vidaJugador + item.value, 100);
        updateHealthBar();
        showPickup("+25 Salud");
      } else if (item.type === "key") {
        inventory.key = true;
        inventory.updateDisplay();
        showPickup("¡Llave obtenida!");
        portal.material.emissiveColor = new BABYLON.Color3(0.8, 0.2, 1);
      }
      
      item.mesh.dispose();
      items.splice(i, 1);
    }
  }
}

// Ataque del jugador
function playerAttack() {
  const hitEnemies = [];
  
  // Efecto visual
  const flash = new BABYLON.PointLight("attackFlash", camera.position, scene);
  flash.diffuse = new BABYLON.Color3(1, 0.5, 0);
  flash.range = config.attackRange;
  setTimeout(() => flash.dispose(), 100);
  
  // Verificar enemigos en rango
  enemies.forEach(enemy => {
    if (enemy.health > 0) {
      const distance = BABYLON.Vector3.Distance(camera.position, enemy.mesh.position);
      if (distance <= config.attackRange) {
        enemy.health -= config.playerAttackDamage;
        hitEnemies.push(enemy);
      }
    }
  });
  
  if (hitEnemies.length > 0) {
    showPickup(`Golpeaste ${hitEnemies.length} enemigos`);
  }
}

// Magia del jugador
function castMagic() {
  const magicLight = new BABYLON.HemisphericLight("magicLight", camera.position, scene);
  magicLight.diffuse = new BABYLON.Color3(0.2, 0.4, 1);
  magicLight.groundColor = new BABYLON.Color3(0.1, 0.2, 0.5);
  setTimeout(() => magicLight.dispose(), 200);
  
  enemies.forEach(enemy => {
    if (enemy.health > 0) {
      const distance = BABYLON.Vector3.Distance(camera.position, enemy.mesh.position);
      if (distance <= config.attackRange * 1.5) {
        enemy.health -= config.playerAttackDamage * 0.7;
      }
    }
  });
}

// Verificar portal
function checkPortal() {
  if (portal && inventory.key) {
    const distance = BABYLON.Vector3.Distance(camera.position, portal.position);
    if (distance < 1.5) {
      showPickup("¡Entrando al siguiente nivel!");
      setTimeout(() => {
        window.location.href = "nivel2.html";
      }, 1000);
    }
  }
}

// Bucle principal del juego
engine.runRenderLoop(() => {
  // Movimiento del jugador
  const forward = camera.getDirection(BABYLON.Axis.Z);
  const right = camera.getDirection(BABYLON.Axis.X);
  const movement = forward.scale(joyY * 0.1).add(right.scale(joyX * 0.1));
  camera.position.addInPlace(movement);
  
  // Movimiento de enemigos
  enemies.forEach(enemy => {
    if (enemy.health > 0) {
      const direction = camera.position.subtract(enemy.mesh.position).normalize();
      enemy.mesh.moveWithCollisions(direction.scale(enemy.speed));
    } else if (enemy.mesh) {
      enemy.mesh.dispose();
      enemy.mesh = null;
    }
  });
  
  // Verificar colisiones
  checkItemCollisions();
  checkPortal();
  
  // Renderizar escena
  scene.render();
});

// Eventos de botones
document.getElementById("btnAttack").onclick = playerAttack;
document.getElementById("btnMagic").onclick = castMagic;

// Redimensionar
window.addEventListener("resize", () => engine.resize());
</script>
</body>
</html>
