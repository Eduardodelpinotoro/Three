<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<title>Juego nivel 1</title>
<style>
  html,body{margin:0;overflow:hidden;background:#000}
  #renderCanvas{width:100%;height:100%}
  #joystick-container{position:absolute;bottom:30px;left:30px;width:150px;height:150px;z-index:10}
  .button{position:absolute;bottom:30px;width:60px;height:60px;background:rgba(255,255,255,0.2);border-radius:50%;pointer-events:auto;}
  #btnAttack{right:100px} #btnMagic{right:180px}
  #healthBarContainer{position:absolute;top:10px;left:10px;width:200px;height:20px;background:#444;border:1px solid #fff}
  #healthBar{height:100%;width:50%;background:#0f0;transition:width .3s}
  #pickupMsg{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);color:#0ff;font-weight:bold;font-size:22px;opacity:0;pointer-events:none;transition:opacity .3s;}
  #key-indicator {
    position: absolute;
    top: 50px;
    right: 20px;
    width: 30px;
    height: 30px;
    background-image: url('https://i.ibb.co/HpKK2xwJ/1000012289-removebg-preview.png');
    background-size: contain;
    background-repeat: no-repeat;
    opacity: 0;
    transition: opacity 0.3s;
  }
</style>
</head>
<body>
<canvas id="renderCanvas"></canvas>
<div id="joystick-container"></div>
<div id="healthBarContainer"><div id="healthBar"></div></div>
<div id="pickupMsg"></div>
<div id="key-indicator"></div>
<div class="button" id="btnAttack"></div>
<div class="button" id="btnMagic"></div>

<script src="https://cdn.jsdelivr.net/npm/nipplejs@0.9.0/dist/nipplejs.min.js"></script>
<script src="https://cdn.babylonjs.com/babylon.js"></script>
<script src="https://cdn.babylonjs.com/loaders/babylon.glTF2FileLoader.min.js"></script>

<script>
const canvas = document.getElementById("renderCanvas");
const engine = new BABYLON.Engine(canvas,true);
const scene = new BABYLON.Scene(engine);
scene.preventDefaultOnDoubleClick = false;
scene.collisionsEnabled = true;
scene.gravity = new BABYLON.Vector3(0,-9.81,0);

const camera = new BABYLON.FreeCamera("cam", new BABYLON.Vector3(-1,2,-5), scene);
camera.attachControl(canvas,true);
camera.inputs.attached.mousewheel?.detachControl(canvas);
camera.checkCollisions = true;
camera.applyGravity = true;
camera.ellipsoid = new BABYLON.Vector3(1,1,1);
camera.maxStepHeight = 2;

new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0,1,0), scene);

let vidaJugador = 50;
const healthBar = document.getElementById("healthBar");
const pickupMsg = document.getElementById("pickupMsg");
const keyIndicator = document.getElementById("key-indicator");

function updateHealthBar(){
  healthBar.style.width = Math.min(vidaJugador,100) + "%";
  if(vidaJugador <= 0){ alert("Has perdido"); location.reload(); }
}
updateHealthBar();

function showPickup(text, color="#0ff"){
  pickupMsg.textContent = text;
  pickupMsg.style.color = color;
  pickupMsg.style.opacity = 1;
  setTimeout(()=> pickupMsg.style.opacity = 0, 1000);
}

let joyX=0, joyY=0;
const joystick = nipplejs.create({
  zone: document.getElementById("joystick-container"),
  mode: "static", position:{left:"75px",bottom:"75px"},
  size:120, color:"white"
});
joystick.on("move", (_,d)=>{ joyX=d.vector.x; joyY=d.vector.y; });
joystick.on("end", ()=>{ joyX=0; joyY=0; });

const config = { 
  attackRange:5, 
  playerAttackDamage:20,
  attackAngle: 0.5,
  magicDamage: 30,
  magicRange: 7
};

const enemies = [], items = [], itemMeshes = [];
let portalMesh=null, portalActive=false, hasKey=false;

// Texturas para los items
const textures = {
  healthPotion: { src: 'https://i.ibb.co/Xr1rftKg/1b452991-913b-4dbe-8f25-43f7108d1d70.png', texture: null },
  magicPotion: { src: 'https://i.ibb.co/MxL47LQK/5d7ced27-56f6-489a-819a-2c2cc121d597.png', texture: null },
  key: { src: 'https://i.ibb.co/HpKK2xwJ/1000012289-removebg-preview.png', texture: null }
};

// Cargar texturas
function loadTextures() {
  textures.healthPotion.texture = new BABYLON.Texture(textures.healthPotion.src, scene);
  textures.magicPotion.texture = new BABYLON.Texture(textures.magicPotion.src, scene);
  textures.key.texture = new BABYLON.Texture(textures.key.src, scene);
}

// Carga del mapa
BABYLON.SceneLoader.Append("", "mapa.glb", scene, ()=>{
  scene.meshes.forEach(m=>m.checkCollisions=true);
  camera.position = new BABYLON.Vector3(-1,1,-5);
  loadTextures();
  initEntities();
});

function initEntities(){
  // Enemigos
  [{x:2,z:2},{x:-3,z:1},{x:5,z:-4}].forEach(e=>enemies.push(createEnemy(e.x,e.z)));
  
  // Items - posición Y aumentada a 1.5 para que estén a la altura del jugador
  createItem(1,0,"health");
  createItem(-2,-2,"magic");
  createItem(-1,3,"key");
  
  // Portal
  portalMesh = BABYLON.MeshBuilder.CreateCylinder("portal",{height:0.1,diameter:1.5},scene);
  portalMesh.position = new BABYLON.Vector3(4,0.05,4);
  const pMat = new BABYLON.StandardMaterial("portalMaterial",scene);
  pMat.emissiveColor = new BABYLON.Color3(0.5,0,1);
  pMat.alpha=0.7;
  portalMesh.material = pMat;
  
  scene.registerBeforeRender(function() {
    portalMesh.rotation.y += 0.01;
  });
}

function createEnemy(x,z){
  const c={mesh:null,health:50};
  BABYLON.SceneLoader.ImportMeshAsync(null,"","bat.glb",scene).then(r=>{
    const m=r.meshes[0];
    m.position=new BABYLON.Vector3(x,1.8,z);
    m.scaling=new BABYLON.Vector3(0.07,0.07,0.07);
    m.checkCollisions=true;
    c.mesh=m;
  });
  return c;
}

function createItem(x,z,type){
  let mesh, material;
  const itemSize = 0.3;
  
  if (type === 'health') {
    mesh = BABYLON.MeshBuilder.CreatePlane(`health_${x}_${z}`, { width: itemSize, height: itemSize }, scene);
    material = new BABYLON.StandardMaterial(`healthMat_${x}_${z}`, scene);
    material.diffuseTexture = textures.healthPotion.texture;
    mesh.billboardMode = BABYLON.Mesh.BILLBOARDMODE_ALL;
    material.specularColor = new BABYLON.Color3(0, 0, 0);
  } 
  else if (type === 'magic') {
    mesh = BABYLON.MeshBuilder.CreatePlane(`magic_${x}_${z}`, { width: itemSize, height: itemSize }, scene);
    material = new BABYLON.StandardMaterial(`magicMat_${x}_${z}`, scene);
    material.diffuseTexture = textures.magicPotion.texture;
    mesh.billboardMode = BABYLON.Mesh.BILLBOARDMODE_ALL;
    material.specularColor = new BABYLON.Color3(0, 0, 0);
  }
  else if (type === 'key') {
    mesh = BABYLON.MeshBuilder.CreatePlane(`key_${x}_${z}`, { width: itemSize, height: itemSize }, scene);
    material = new BABYLON.StandardMaterial(`keyMat_${x}_${z}`, scene);
    material.diffuseTexture = textures.key.texture;
    mesh.billboardMode = BABYLON.Mesh.BILLBOARDMODE_ALL;
    material.specularColor = new BABYLON.Color3(0, 0, 0);
  }
  
  mesh.material = material;
  // Cambiado de 0.5 a 1.5 para que estén a la altura del jugador
  mesh.position = new BABYLON.Vector3(x,1.5,z);
  mesh.checkCollisions = false;
  
  const itemLight = new BABYLON.PointLight(`itemLight_${x}_${z}`,
    new BABYLON.Vector3(x,1.5,z), scene);
  itemLight.intensity = 0.5;
  itemLight.range = 2;
  
  if (type === 'health') {
    itemLight.diffuse = new BABYLON.Color3(1, 0, 0);
  } else if (type === 'magic') {
    itemLight.diffuse = new BABYLON.Color3(0, 0.5, 1);
  } else if (type === 'key') {
    itemLight.diffuse = new BABYLON.Color3(1, 0.8, 0);
  }
  
  const animation = new BABYLON.Animation(
    `itemAnim_${x}_${z}`, 'position.y', 30,
    BABYLON.Animation.ANIMATIONTYPE_FLOAT,
    BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE
  );
  
  const keys = [];
  keys.push({ frame: 0, value: 1.5 });
  keys.push({ frame: 30, value: 1.7 });
  keys.push({ frame: 60, value: 1.5 });
  
  animation.setKeys(keys);
  mesh.animations = [animation];
  scene.beginAnimation(mesh, 0, 60, true);
  
  items.push({x,z,type});
  itemMeshes.push({
    mesh: mesh,
    light: itemLight,
    data: {x,z,type}
  });
}

function checkItemCollisions(){
  for(let i=itemMeshes.length-1;i>=0;i--){
    const obj=itemMeshes[i];
    const dist=BABYLON.Vector3.Distance(
      new BABYLON.Vector3(camera.position.x, 1.5, camera.position.z),
      obj.mesh.position
    );
    if(dist<1.5){
      collectItem(obj.data);
      items.splice(items.findIndex(it=>it.x===obj.data.x&&it.z===obj.data.z&&it.type===obj.data.type),1);
      obj.mesh.dispose(); 
      obj.light.dispose(); 
      itemMeshes.splice(i,1);
    }
  }
}

function collectItem(item){
  if(item.type==="health"){
    vidaJugador=Math.min(vidaJugador+25,100);
    updateHealthBar(); 
    showPickup("+25 Salud", "#0f0");
  } 
  else if(item.type==="magic"){
    showPickup("+30 Magia", "#06f");
  }
  else if(item.type==="key"){
    hasKey=true; 
    keyIndicator.style.opacity = '1';
    activatePortal();
    showPickup("¡Llave obtenida!", "#ff0");
  }
}

function activatePortal() {
  portalActive = true;
  portalMesh.position.y = 1;
  const portalMaterial = new BABYLON.StandardMaterial("activePortalMaterial", scene);
  portalMaterial.emissiveColor = new BABYLON.Color3(0.8, 0.2, 1);
  portalMaterial.alpha = 0.8;
  portalMesh.material = portalMaterial;
  
  const particleSystem = new BABYLON.ParticleSystem("portalParticles", 2000, scene);
  particleSystem.particleTexture = new BABYLON.Texture("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=", scene);
  particleSystem.emitter = portalMesh;
  particleSystem.minEmitBox = new BABYLON.Vector3(-0.7, 0, -0.7);
  particleSystem.maxEmitBox = new BABYLON.Vector3(0.7, 0.1, 0.7);
  particleSystem.color1 = new BABYLON.Color4(0.7, 0.2, 1, 1);
  particleSystem.color2 = new BABYLON.Color4(0.3, 0.1, 0.6, 1);
  particleSystem.colorDead = new BABYLON.Color4(0, 0, 0.2, 0);
  particleSystem.minSize = 0.1;
  particleSystem.maxSize = 0.3;
  particleSystem.minLifeTime = 0.3;
  particleSystem.maxLifeTime = 1.5;
  particleSystem.emitRate = 100;
  particleSystem.direction1 = new BABYLON.Vector3(-1, 8, -1);
  particleSystem.direction2 = new BABYLON.Vector3(1, 8, 1);
  particleSystem.minEmitPower = 1;
  particleSystem.maxEmitPower = 3;
  particleSystem.updateSpeed = 0.01;
  particleSystem.start();
}

function playerAttack() {
  // Rayo más preciso
  const ray = new BABYLON.Ray(
    camera.position, 
    camera.getForwardRay().direction,
    config.attackRange
  );
  
  const flash = new BABYLON.PointLight("attackFlash", 
    camera.position.add(camera.getForwardRay().direction.scale(2)), 
    scene);
  flash.diffuse = new BABYLON.Color3(1, 0.5, 0);
  flash.range = 10;
  flash.intensity = 1;
  
  setTimeout(() => flash.dispose(), 100);
  
  let hitEnemy = false;
  
  enemies.forEach((enemy, index) => {
    if (!enemy.mesh || enemy.health <= 0) return;
    
    const rayHelper = new BABYLON.RayHelper(ray);
    rayHelper.show(scene);
    setTimeout(() => rayHelper.dispose(), 100);
    
    // Verificar colisión con el rayo
    const hit = enemy.mesh.intersectsRay(ray);
    if (hit.hit) {
      enemy.health -= config.playerAttackDamage;
      hitEnemy = true;
      
      const impactPoint = hit.pickedPoint;
      const impactParticles = new BABYLON.ParticleSystem("impactParticles", 50, scene);
      impactParticles.particleTexture = new BABYLON.Texture("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=", scene);
      impactParticles.emitter = impactPoint;
      impactParticles.color1 = new BABYLON.Color4(1, 0, 0, 1);
      impactParticles.color2 = new BABYLON.Color4(0.5, 0, 0, 1);
      impactParticles.minSize = 0.05;
      impactParticles.maxSize = 0.2;
      impactParticles.minLifeTime = 0.2;
      impactParticles.maxLifeTime = 0.6;
      impactParticles.emitRate = 300;
      impactParticles.minEmitPower = 1;
      impactParticles.maxEmitPower = 3;
      impactParticles.updateSpeed = 0.02;
      impactParticles.start();
      
      setTimeout(() => {
        impactParticles.stop();
        setTimeout(() => impactParticles.dispose(), 1000);
      }, 200);
      
      if (enemy.health <= 0) {
        showPickup("¡Enemigo eliminado!", "#f00");
        
        const duration = 30;
        const shrinkAnimation = new BABYLON.Animation(
          "enemyShrinkAnimation", "scaling", 30,
          BABYLON.Animation.ANIMATIONTYPE_VECTOR3,
          BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT
        );
        
        const sinkAnimation = new BABYLON.Animation(
          "enemySinkAnimation", "position.y", 30,
          BABYLON.Animation.ANIMATIONTYPE_FLOAT,
          BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT
        );
        
        const scaleKeys = [
          { frame: 0, value: enemy.mesh.scaling.clone() },
          { frame: duration, value: new BABYLON.Vector3(0.1, 0.1, 0.1) }
        ];
        
        const positionKeys = [
          { frame: 0, value: enemy.mesh.position.y },
          { frame: duration, value: -1 }
        ];
        
        shrinkAnimation.setKeys(scaleKeys);
        sinkAnimation.setKeys(positionKeys);
        
        enemy.mesh.animations = [shrinkAnimation, sinkAnimation];
        const animatable = scene.beginAnimation(enemy.mesh, 0, duration, false);
        
        animatable.onAnimationEnd = function() {
          enemy.mesh.dispose();
          enemies.splice(index, 1);
        };
      }
    }
  });
  
  return hitEnemy;
}

function castMagic(){
  const magicCenter = camera.position.add(camera.getForwardRay().direction.scale(3));
  
  // Flash azul
  const magicFlash = new BABYLON.HemisphericLight("magicFlash", magicCenter, scene);
  magicFlash.diffuse = new BABYLON.Color3(0.2, 0.4, 1);
  magicFlash.groundColor = new BABYLON.Color3(0.1, 0.2, 0.5);
  magicFlash.intensity = 20;
  
  // Esfera de energía
  const magicSphere = BABYLON.MeshBuilder.CreateSphere("magicSphere", {diameter: 1}, scene);
  magicSphere.position = magicCenter;
  const sphereMat = new BABYLON.StandardMaterial("sphereMat", scene);
  sphereMat.emissiveColor = new BABYLON.Color3(0.3, 0.5, 1);
  sphereMat.alpha = 0.8;
  magicSphere.material = sphereMat;
  
  // Partículas
  const particles = new BABYLON.ParticleSystem("magicParticles", 1000, scene);
  particles.particleTexture = new BABYLON.Texture("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=", scene);
  particles.emitter = magicCenter;
  particles.color1 = new BABYLON.Color4(0.4, 0.6, 1, 1);
  particles.color2 = new BABYLON.Color4(0.2, 0.3, 0.8, 1);
  particles.minSize = 0.2;
  particles.maxSize = 0.5;
  particles.minLifeTime = 0.5;
  particles.maxLifeTime = 1.2;
  particles.emitRate = 800;
  particles.direction1 = new BABYLON.Vector3(-1, 0, -1).normalize();
  particles.direction2 = new BABYLON.Vector3(1, 0, 1).normalize();
  particles.minEmitPower = 3;
  particles.maxEmitPower = 6;
  particles.start();
  
  // Aplicar daño en área
  let enemiesHit = 0;
  enemies.forEach(enemy => {
    if (!enemy.mesh || enemy.health <= 0) return;
    
    const dist = BABYLON.Vector3.Distance(magicCenter, enemy.mesh.position);
    if (dist <= config.magicRange) {
      enemy.health -= config.magicDamage;
      enemiesHit++;
      
      if (enemy.health <= 0) {
        enemy.mesh.dispose();
      }
    }
  });
  
  if (enemiesHit > 0) {
    showPickup(`¡Magia afectó a ${enemiesHit} enemigos!`, "#06f");
  }
  
  // Animación de explosión
  let animFrame = 0;
  const maxFrames = 30;
  
  const explosionAnim = scene.registerBeforeRender(() => {
    animFrame++;
    
    const sphereScale = 1 + (animFrame/10);
    magicSphere.scaling = new BABYLON.Vector3(sphereScale, sphereScale, sphereScale);
    sphereMat.alpha = 0.8 - (animFrame/maxFrames)*0.8;
    
    magicFlash.intensity = 20 - (animFrame/maxFrames)*20;
    
    if (animFrame >= maxFrames) {
      scene.unregisterBeforeRender(explosionAnim);
      magicSphere.dispose();
      magicFlash.dispose();
      particles.stop();
      setTimeout(() => particles.dispose(), 1000);
    }
  });
}

document.getElementById("btnAttack").onclick = playerAttack;
document.getElementById("btnMagic").onclick = castMagic;

engine.runRenderLoop(()=>{
  const f=camera.getDirection(BABYLON.Axis.Z), r=camera.getDirection(BABYLON.Axis.X);
  camera.cameraDirection = BABYLON.Vector3.Zero()
    .addInPlace(f.scale(joyY*0.1))
    .addInPlace(r.scale(joyX*0.1));

  enemies.forEach(e=>{
    if(e.mesh){
      const dir = camera.position.subtract(e.mesh.position), dist=dir.length();
      if(dist<30 && dist>1){
        e.mesh.moveWithCollisions(dir.normalize().scale(0.06));
      }
    }
  });

  checkItemCollisions();

  if(portalMesh && portalActive && hasKey && BABYLON.Vector3.Distance(camera.position,portalMesh.position)<1.5){
    const enemiesNearby = enemies.some(enemy => {
      if (!enemy.mesh || enemy.health <= 0) return false;
      const dx = enemy.mesh.position.x - portalMesh.position.x;
      const dz = enemy.mesh.position.z - portalMesh.position.z;
      return Math.sqrt(dx * dx + dz * dz) < 5;
    });
    
    if (enemiesNearby) {
      showPickup('¡Elimina a los enemigos cercanos primero!', '#f00');
      return;
    }
    
    showPickup(`¡Nivel completado!`, '#0ff');
    
    setTimeout(() => {
      window.location.href = "nivel2.html";
    }, 1500);
  }

  scene.render();
});

window.addEventListener("resize",()=>engine.resize());
</script>
</body>
</html>
