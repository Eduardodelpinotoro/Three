<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Dungeon Joystick con .glb</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <style>
    html, body { margin:0;padding:0;width:100%;height:100%;overflow:hidden;background:#000; }
    #renderCanvas { width:100%;height:100%; touch-action:none; }
  </style>
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/nipplejs@0.8.5/dist/nipplejs.min.js"></script>
</head>
<body>
  <canvas id="renderCanvas"></canvas>
  <div id="joyzone" style="position:absolute; bottom:20px; left:20px; width:120px; height:120px; touch-action:none;"></div>
  <script>
    const canvas = document.getElementById("renderCanvas");
    const engine = new BABYLON.Engine(canvas, true);
    const scene = new BABYLON.Scene(engine);
    scene.collisionsEnabled = true;
    scene.gravity = new BABYLON.Vector3(0, -9.81, 0);

    const camera = new BABYLON.UniversalCamera("cam", new BABYLON.Vector3(0,2,0), scene);
    camera.attachControl(canvas,true);
    camera.checkCollisions = true;
    camera.applyGravity = true;
    camera.ellipsoid = new BABYLON.Vector3(1,2,1);
    camera.speed = 0.0; // se moverÃ¡ SOLO por joystick

    new BABYLON.HemisphericLight("light", BABYLON.Axis.Y.scale(1), scene);

    // Cargar GLB
    BABYLON.SceneLoader.Append("", "mapa.glb", scene, function() {
      scene.meshes.forEach(m => { m.checkCollisions = true; m.receiveShadows = true; });
    });

    // Joystick con nipple.js
    const joyzone = document.getElementById("joyzone");
    const manager = nipplejs.create({
      zone: joyzone,
      mode: 'static',
      position: { left: '60px', bottom: '60px' },
      color: 'white',
      size: 120
    });

    let joyX = 0, joyY = 0;
    manager.on('move', (evt, data) => {
      const rad = data.angle.radian;
      const dist = data.distance / (120/2);
      joyX = Math.cos(rad) * dist;
      joyY = Math.sin(rad) * dist;
    });
    manager.on('end', () => { joyX = joyY = 0; });

    engine.runRenderLoop(() => {
      const forward = camera.getDirection(BABYLON.Axis.Z).scale(-joyY * 0.1);
      const right = camera.getDirection(BABYLON.Axis.X).scale(joyX * 0.1);
      camera.moveWithCollisions(forward.add(right));
      scene.render();
    });

    window.addEventListener("resize", () => engine.resize());
  </script>
</body>
</html>
