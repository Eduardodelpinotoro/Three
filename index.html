<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<title>Juego nivel 1</title>
<style>
  html,body{margin:0;overflow:hidden;background:#000}
  #renderCanvas{width:100%;height:100%}
  #joystick-container{position:absolute;bottom:30px;left:30px;width:150px;height:150px;z-index:10}
  .button{position:absolute;bottom:30px;width:60px;height:60px;background:rgba(255,255,255,0.2);border-radius:50%;pointer-events:auto;}
  #btnAttack{right:100px} #btnMagic{right:180px}
  #healthBarContainer{position:absolute;top:10px;left:10px;width:200px;height:20px;background:#444;border:1px solid #fff}
  #healthBar{height:100%;width:50%;background:#0f0;transition:width .3s}
  #pickupMsg{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);color:#0ff;font-weight:bold;font-size:22px;opacity:0;pointer-events:none;transition:opacity .3s;}
  #key-indicator {
    position: absolute;
    top: 50px;
    right: 20px;
    width: 30px;
    height: 30px;
    background-image: url('https://i.ibb.co/HpKK2xwJ/1000012289-removebg-preview.png');
    background-size: contain;
    background-repeat: no-repeat;
    opacity: 0;
    transition: opacity 0.3s;
  }
</style>
</head>
<body>
<canvas id="renderCanvas"></canvas>
<div id="joystick-container"></div>
<div id="healthBarContainer"><div id="healthBar"></div></div>
<div id="pickupMsg"></div>
<div id="key-indicator"></div>
<div class="button" id="btnAttack"></div>
<div class="button" id="btnMagic"></div>

<script src="https://cdn.jsdelivr.net/npm/nipplejs@0.9.0/dist/nipplejs.min.js"></script>
<script src="https://cdn.babylonjs.com/babylon.js"></script>
<script src="https://cdn.babylonjs.com/loaders/babylon.glTF2FileLoader.min.js"></script>

<script>
const canvas = document.getElementById("renderCanvas");
const engine = new BABYLON.Engine(canvas, true);
const scene = new BABYLON.Scene(engine);
scene.gravity = new BABYLON.Vector3(0, -9.81, 0);
scene.collisionsEnabled = true;

const camera = new BABYLON.FreeCamera("camera", new BABYLON.Vector3(0, 1.5, -10), scene);
camera.attachControl(canvas, true);
camera.ellipsoid = new BABYLON.Vector3(0.5, 1, 0.5);
camera.checkCollisions = true;
camera.applyGravity = true;

// Luz
new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);

// Variables del juego
let vidaJugador = 100;
const healthBar = document.getElementById("healthBar");
const pickupMsg = document.getElementById("pickupMsg");
const keyIndicator = document.getElementById("key-indicator");

// Configuración
const config = {
  attackRange: 5,
  playerAttackDamage: 20,
  magicDamage: 30,
  magicRange: 7
};

// Objetos del juego
const enemies = [];
const items = [];
let portalMesh = null;
let hasKey = false;
let portalActive = false;
let canTeleport = true; // Para evitar múltiples activaciones

// Texturas
const textures = {
  healthPotion: { src: 'https://i.ibb.co/Xr1rftKg/1b452991-913b-4dbe-8f25-43f7108d1d70.png' },
  magicPotion: { src: 'https://i.ibb.co/MxL47LQK/5d7ced27-56f6-489a-819a-2c2cc121d597.png' },
  key: { src: 'https://i.ibb.co/HpKK2xwJ/1000012289-removebg-preview.png' }
};

// Inicialización del juego
function initGame() {
  // Cargar texturas
  for (const key in textures) {
    textures[key].texture = new BABYLON.Texture(textures[key].src, scene);
  }

  // Crear enemigos
  createEnemy(2, 2);
  createEnemy(-3, 1);
  createEnemy(5, -4);

  // Crear items
  createItem(1, 0, "health");
  createItem(-2, -2, "magic");
  createItem(-1, 3, "key");

  // Crear portal
  createPortal(4, 4);
}

function createEnemy(x, z) {
  BABYLON.SceneLoader.ImportMeshAsync(null, "", "bat.glb", scene).then(result => {
    const enemyMesh = result.meshes[0];
    enemyMesh.position = new BABYLON.Vector3(x, 0, z);
    enemyMesh.scaling = new BABYLON.Vector3(0.07, 0.07, 0.07);
    enemyMesh.checkCollisions = true;
    
    enemies.push({
      mesh: enemyMesh,
      health: 50,
      position: new BABYLON.Vector3(x, 0, z)
    });
  });
}

function createItem(x, z, type) {
  const itemSize = 0.3;
  const mesh = BABYLON.MeshBuilder.CreatePlane(type, { width: itemSize, height: itemSize }, scene);
  mesh.billboardMode = BABYLON.Mesh.BILLBOARDMODE_ALL;
  mesh.position = new BABYLON.Vector3(x, 1.5, z);
  
  const material = new BABYLON.StandardMaterial(type + "Mat", scene);
  material.diffuseTexture = textures[type].texture;
  material.specularColor = new BABYLON.Color3(0, 0, 0);
  mesh.material = material;

  // Luz del item
  const light = new BABYLON.PointLight(type + "Light", mesh.position, scene);
  light.intensity = 0.5;
  light.range = 2;
  light.diffuse = type === "health" ? new BABYLON.Color3(1, 0, 0) :
                 type === "magic" ? new BABYLON.Color3(0, 0.5, 1) :
                 new BABYLON.Color3(1, 0.8, 0);

  // Animación de flotación
  const animation = new BABYLON.Animation(
    type + "Anim", "position.y", 30,
    BABYLON.Animation.ANIMATIONTYPE_FLOAT,
    BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE
  );

  const keys = [
    { frame: 0, value: 1.5 },
    { frame: 15, value: 1.7 },
    { frame: 30, value: 1.5 }
  ];
  
  animation.setKeys(keys);
  mesh.animations = [animation];
  scene.beginAnimation(mesh, 0, 30, true);

  items.push({
    mesh: mesh,
    light: light,
    type: type,
    position: new BABYLON.Vector3(x, 1.5, z)
  });
}

function createPortal(x, z) {
  portalMesh = BABYLON.MeshBuilder.CreateCylinder("portal", { height: 0.1, diameter: 1.5 }, scene);
  portalMesh.position = new BABYLON.Vector3(x, 0.05, z);
  
  const portalMat = new BABYLON.StandardMaterial("portalMat", scene);
  portalMat.emissiveColor = new BABYLON.Color3(0.5, 0, 1);
  portalMat.alpha = 0.7;
  portalMesh.material = portalMat;

  // Animación de rotación
  scene.registerBeforeRender(() => {
    portalMesh.rotation.y += 0.01;
  });
}

function activatePortal() {
  portalActive = true;
  const activeMat = new BABYLON.StandardMaterial("activePortalMat", scene);
  activeMat.emissiveColor = new BABYLON.Color3(0.8, 0.2, 1);
  activeMat.alpha = 0.8;
  portalMesh.material = activeMat;

  // Efecto de partículas
  const particles = new BABYLON.ParticleSystem("portalParticles", 2000, scene);
  particles.particleTexture = new BABYLON.Texture("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=", scene);
  particles.emitter = portalMesh;
  particles.minEmitBox = new BABYLON.Vector3(-0.7, 0, -0.7);
  particles.maxEmitBox = new BABYLON.Vector3(0.7, 0.1, 0.7);
  particles.color1 = new BABYLON.Color4(0.7, 0.2, 1, 1);
  particles.color2 = new BABYLON.Color4(0.3, 0.1, 0.6, 1);
  particles.minSize = 0.1;
  particles.maxSize = 0.3;
  particles.minLifeTime = 0.3;
  particles.maxLifeTime = 1.5;
  particles.emitRate = 100;
  particles.minEmitPower = 1;
  particles.maxEmitPower = 3;
  particles.start();
}

function checkItemCollisions() {
  for (let i = items.length - 1; i >= 0; i--) {
    const item = items[i];
    const dist = BABYLON.Vector3.Distance(camera.position, item.position);
    
    if (dist < 1.5) {
      collectItem(item, i);
    }
  }
}

function collectItem(item, index) {
  switch(item.type) {
    case "health":
      vidaJugador = Math.min(vidaJugador + 25, 100);
      updateHealthBar();
      showPickup("+25 Salud", "#0f0");
      break;
    case "magic":
      showPickup("+30 Magia", "#06f");
      break;
    case "key":
      hasKey = true;
      keyIndicator.style.opacity = "1";
      showPickup("¡Llave obtenida!", "#ff0");
      activatePortal();
      break;
  }

  // Eliminar el item
  item.mesh.dispose();
  item.light.dispose();
  items.splice(index, 1);
}

function checkPortalCollision() {
  if (!portalActive || !hasKey || !canTeleport) return;

  const dist = BABYLON.Vector3.Distance(camera.position, portalMesh.position);
  if (dist < 1.5) {
    // Verificar enemigos cercanos
    const enemiesNearby = enemies.some(enemy => {
      if (!enemy.mesh || enemy.health <= 0) return false;
      return BABYLON.Vector3.Distance(enemy.mesh.position, portalMesh.position) < 5;
    });

    if (enemiesNearby) {
      showPickup("¡Elimina a los enemigos cercanos primero!", "#f00");
      return;
    }

    canTeleport = false;
    showPickup("¡Portal activado!", "#0ff");
    
    setTimeout(() => {
      window.location.href = "nivel2.html";
    }, 1500);
  }
}

// Resto de funciones (updateHealthBar, showPickup, playerAttack, castMagic) se mantienen igual

// Inicializar controles
function initControls() {
  const joystick = nipplejs.create({
    zone: document.getElementById("joystick-container"),
    mode: "static",
    position: { left: "75px", bottom: "75px" },
    size: 120
  });

  joystick.on("move", (evt, data) => {
    const forward = new BABYLON.Vector3(0, 0, data.vector.y * 0.1);
    const right = new BABYLON.Vector3(data.vector.x * 0.1, 0, 0);
    camera.cameraDirection = forward.add(right);
  });

  joystick.on("end", () => {
    camera.cameraDirection = BABYLON.Vector3.Zero();
  });

  document.getElementById("btnAttack").addEventListener("click", playerAttack);
  document.getElementById("btnMagic").addEventListener("click", castMagic);
}

// Bucle principal
engine.runRenderLoop(() => {
  checkItemCollisions();
  checkPortalCollision();
  scene.render();
});

// Iniciar el juego
initGame();
initControls();

window.addEventListener("resize", () => engine.resize());
</script>
</body>
</html>
