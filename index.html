<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<title>Juego con mapa.glb + enemigos/items/portal/llave</title>
<style>
  html, body { margin:0; width:100%; height:100%; overflow:hidden; background:#000; }
  #renderCanvas { width:100%; height:100%; display:block; }
  #joystick-container { position:absolute; bottom:30px; left:30px; width:150px; height:150px; z-index:10; }
  #hud { position:absolute; top:0; left:0; right:0; bottom:0; pointer-events:none; z-index:20; }
  #crosshair { position:absolute; width:3px; height:3px; background:red; border-radius:50%;
               top:50%; left:50%; margin:-1.5px 0 0 -1.5px; }
  .button { position:absolute; bottom:30px; width:60px; height:60px;
            background:rgba(255,255,255,0.2); border-radius:50%; color:white;
            font-size:24px; text-align:center; line-height:60px;
            user-select:none; pointer-events:auto; }
  #btnAttack { right:100px; }
  #btnBow { right:180px; }
  #hudOverlay { position:absolute; top:10px; left:10px; color:white; font-size:18px; }
  #healthBarContainer { width:200px; height:20px; background:#444; border:1px solid #fff; margin-top:4px; }
  #healthBar { height:100%; width:25%; background:#0f0; transition:width 0.2s; }
</style>
</head>
<body>

<canvas id="renderCanvas"></canvas>
<div id="joystick-container"></div>
<div id="hud">
  <div id="crosshair"></div>
  <div id="btnAttack" class="button">âš”</div>
  <div id="btnBow" class="button">ðŸŽ¯</div>
  <div id="hudOverlay">
    Vida:
    <div id="healthBarContainer"><div id="healthBar"></div></div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/nipplejs@0.9.0/dist/nipplejs.min.js"></script>
<script src="https://cdn.babylonjs.com/babylon.js"></script>
<script src="https://cdn.babylonjs.com/loaders/babylon.glTF2FileLoader.min.js"></script>

<script>
  // Setup bÃ¡sico de Babylon
  const canvas = document.getElementById("renderCanvas");
  const engine = new BABYLON.Engine(canvas, true);
  const scene = new BABYLON.Scene(engine);
  scene.collisionsEnabled = true;
  scene.gravity = new BABYLON.Vector3(0, -9.81, 0);

  const camera = new BABYLON.FreeCamera("cam", new BABYLON.Vector3(1,1,-5), scene);
  camera.attachControl(canvas, true);
  camera.checkCollisions = true;
  camera.applyGravity = true;
  camera.ellipsoid = new BABYLON.Vector3(1,1,1);
  camera.maxStepHeight = 1;

  new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0,1,0), scene);

  // Estado del jugador
  let vidaJugador = 5;
  const barraVida = document.getElementById("healthBar");
  function actualizarVida(){
    barraVida.style.width = Math.min((vidaJugador * 100 / 100),100) + "%";
    if(vidaJugador <= 0){
      alert("Has perdido");
      location.reload();
    }
  }
  actualizarVida();

  // Joystick
  let joyX = 0, joyY = 0;
  const joystick = nipplejs.create({
    zone: document.getElementById('joystick-container'),
    mode: 'static', position: {left:'75px', bottom:'75px'},
    size:120, color:'white'
  });
  joystick.on('move', (_, d) => { joyX = d.vector.x; joyY = d.vector.y; });
  joystick.on('end', () => { joyX = 0; joyY = 0; });

  // Balas
  function crearBala(origen, dir){
    const bala = BABYLON.MeshBuilder.CreateSphere("bala", {diameter:0.3}, scene);
    bala.position = origen.clone();
    const mat = new BABYLON.StandardMaterial("bMat", scene);
    mat.emissiveColor = new BABYLON.Color3(0,1,0);
    bala.material = mat;
    bala._dir = dir.normalize().scale(4);

    bala._obs = scene.onBeforeRenderObservable.add(() => {
      bala.position.addInPlace(bala._dir);
      if(bala.position.y < -10){
        scene.onBeforeRenderObservable.remove(bala._obs);
        bala.dispose();
      }

      // Impacto contra enemigos
      enemies.forEach((e, i) => {
        if(e.mesh && BABYLON.Vector3.Distance(e.mesh.position, bala.position) < 1){
          e.health -= 25;
          if(e.health <= 0){
            e.mesh.dispose();
            enemies.splice(i,1);
          }
          scene.onBeforeRenderObservable.remove(bala._obs);
          bala.dispose();
        }
      });
    });
    setTimeout(() => {
      scene.onBeforeRenderObservable.remove(bala._obs);
      if (!bala.isDisposed()) bala.dispose();
    }, 2000);
  }
  document.getElementById("btnBow").onclick = () => crearBala(
    camera.position.add(camera.getDirection(BABYLON.Axis.Z).scale(2)),
    camera.getDirection(BABYLON.Axis.Z));
  document.getElementById("btnAttack").onclick = () => {
    const atk = BABYLON.MeshBuilder.CreateBox("atk", {size:1}, scene);
    atk.position = camera.position.add(camera.getDirection(BABYLON.Axis.Z).scale(2));
    setTimeout(()=> atk.dispose(), 200);
  };

  // Variables globales del juego
  const enemies = [];
  const items = [];
  const itemMeshes = [];
  let portalMesh = null;
  let portalActive = false;
  let hasKey = false;

  // Iniciar el mapa
  BABYLON.SceneLoader.Append("", "mapa.glb", scene, () => {
    scene.meshes.forEach(m => { m.checkCollisions = true; });
    camera.position = new BABYLON.Vector3(1,1,-5);
    initEntities();
  });

  // Crear enemigos, pociÃ³n, llave y portal
  function initEntities(){
    [{x:2,z:2},{x:-3,z:1},{x:5,z:-4}].forEach(e => enemies.push(createEnemy(e.x,e.z)));

    const texHealth = new BABYLON.StandardMaterial("",scene);
    texHealth.diffuseTexture = new BABYLON.Texture("https://i.ibb.co/Xr1rftKg/1b452991-913b-4dbe-8f25-43f7108d1d70.png", scene);
    createItem(1,0,"health", texHealth);

    const texKey = new BABYLON.StandardMaterial("",scene);
    texKey.diffuseTexture = new BABYLON.Texture("https://i.ibb.co/HpKK2xwJ/1000012289-removebg-preview.png", scene);
    createItem(-1,3,"key", texKey);

    portalMesh = BABYLON.MeshBuilder.CreateCylinder("portal",{height:0.1,diameter:1.5},scene);
    portalMesh.position=new BABYLON.Vector3(4,0.05,4);
    const pMat = new BABYLON.StandardMaterial("pMat",scene);
    pMat.emissiveColor=new BABYLON.Color3(0.5,0,1);
    pMat.alpha=0.7;
    portalMesh.material=pMat;
  }

  function createEnemy(x,z){
    const c = { mesh: null, health: 50 };
    BABYLON.SceneLoader.ImportMesh("", "", "bat.glb", scene, (meshes) => {
      const m = meshes[0];
      m.position = new BABYLON.Vector3(x,1.8,z);
      m.scaling = new BABYLON.Vector3(0.07,0.07,0.07);
      m.checkCollisions = true;
      c.mesh = m;
    });
    return c;
  }

  function createItem(x,z,type, mat){
    const mesh = BABYLON.MeshBuilder.CreatePlane(type, {width:0.3, height:0.3}, scene);
    mesh.billboardMode = BABYLON.Mesh.BILLBOARDMODE_ALL;
    mesh.position = new BABYLON.Vector3(x,0.5,z);
    mesh.material = mat;
    const light = new BABYLON.PointLight("itemLight", mesh.position, scene);
    items.push({x,z,type});
    itemMeshes.push({mesh, light, data:{x,z,type}});
  }

  // ColisiÃ³n con Ã­tems
  function checkItemCollisions(){
    for(let i = itemMeshes.length-1; i>=0; i--){
      const obj = itemMeshes[i];
      const mesh = obj.mesh;
      const dx = mesh.position.x - camera.position.x;
      const dz = mesh.position.z - camera.position.z;
      const dist = Math.sqrt(dx*dx+dz*dz);
      if(dist < 1.5){
        collectItem(obj.data);
        // quitar de gameState
        const idx = items.findIndex(it =>
          it.x===obj.data.x && it.z===obj.data.z && it.type===obj.data.type);
        if(idx!==-1) items.splice(idx,1);
        mesh.dispose();
        obj.light.dispose();
        itemMeshes.splice(i,1);
      }
    }
  }

  function collectItem(item){
    if(item.type==="health"){
      vidaJugador = Math.min(vidaJugador+25,100);
      actualizarVida();
      alert("+25 Salud");
    } else if(item.type==="key"){
      hasKey = true;
      portalActive = true;
      portalMesh.material.emissiveColor = new BABYLON.Color3(0.8,0.2,1);
      portalMesh.material.alpha = 0.8;
      alert("Â¡Llave recogida!");
    }
  }

  // Bucle principal
  engine.runRenderLoop(() => {
    const f = camera.getDirection(BABYLON.Axis.Z);
    const r = camera.getDirection(BABYLON.Axis.X);
    camera.cameraDirection = BABYLON.Vector3.Zero().addInPlace(f.scale(joyY*0.1)).addInPlace(r.scale(joyX*0.1));

    enemies.forEach(e => {
      if(e.mesh){
        const dir = camera.position.subtract(e.mesh.position);
        const dist = dir.length();
        if(dist<30 && dist>1){
          e.mesh.moveWithCollisions(dir.normalize().scale(0.06));
        }
      }
    });

    if(itemMeshes.length > 0) checkItemCollisions();

    if(portalMesh){
      portalMesh.rotation.y += 0.01;
      const d = BABYLON.Vector3.Distance(camera.position, portalMesh.position);
      if(portalActive && hasKey && d<1){
        alert("Â¡Nivel completado!");
        window.location.href = "nivel2.html";
      }
    }

    scene.render();
  });

  window.addEventListener("resize",()=>engine.resize());
</script>
</body>
</html>
