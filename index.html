<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<title>Juego nivel 1</title>
<style>
  html,body{margin:0;overflow:hidden;background:#000}
  #renderCanvas{width:100%;height:100%}
  #joystick-container{position:absolute;bottom:30px;left:30px;width:150px;height:150px;z-index:10}
  .button{position:absolute;bottom:30px;width:60px;height:60px;background:rgba(255,255,255,0.2);border-radius:50%;pointer-events:auto;}
  #btnAttack{right:100px} #btnMagic{right:180px}
  #healthBarContainer{position:absolute;top:10px;left:10px;width:200px;height:20px;background:#444;border:1px solid #fff}
  #healthBar{height:100%;width:50%;background:#0f0;transition:width .3s}
  #pickupMsg{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);color:#0ff;font-weight:bold;font-size:22px;opacity:0;pointer-events:none;transition:opacity .3s;}
</style>
</head>
<body>
<canvas id="renderCanvas"></canvas>
<div id="joystick-container"></div>
<div id="healthBarContainer"><div id="healthBar"></div></div>
<div id="pickupMsg"></div>
<div class="button" id="btnAttack"></div>
<div class="button" id="btnMagic"></div>

<script src="https://cdn.jsdelivr.net/npm/nipplejs@0.9.0/dist/nipplejs.min.js"></script>
<script src="https://cdn.babylonjs.com/babylon.js"></script>
<script src="https://cdn.babylonjs.com/loaders/babylon.glTF2FileLoader.min.js"></script>

<script>
const canvas = document.getElementById("renderCanvas");
const engine = new BABYLON.Engine(canvas,true);
const scene = new BABYLON.Scene(engine);
scene.preventDefaultOnDoubleClick = false;
scene.collisionsEnabled = true;
scene.gravity = new BABYLON.Vector3(0,-9.81,0);

const camera = new BABYLON.FreeCamera("cam", new BABYLON.Vector3(1,2.8,-5), scene);
camera.attachControl(canvas,true);
camera.inputs.attached.mousewheel?.detachControl(canvas);
camera.checkCollisions = true;
camera.applyGravity = true;
camera.ellipsoid = new BABYLON.Vector3(1,1,1);
camera.maxStepHeight = 1;

new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0,1,0), scene);

let vidaJugador = 50;
const healthBar = document.getElementById("healthBar");
const pickupMsg = document.getElementById("pickupMsg");

function updateHealthBar(){
  healthBar.style.width = Math.min(vidaJugador,100) + "%";
  if(vidaJugador <= 0){ alert("Has perdido"); location.reload(); }
}
updateHealthBar();

function showPickup(text){
  pickupMsg.textContent = text;
  pickupMsg.style.opacity = 1;
  setTimeout(()=> pickupMsg.style.opacity = 0, 1000);
}

let joyX=0, joyY=0;
const joystick = nipplejs.create({
  zone: document.getElementById("joystick-container"),
  mode: "static", position:{left:"75px",bottom:"75px"},
  size:120, color:"white"
});
joystick.on("move", (_,d)=>{ joyX=d.vector.x; joyY=d.vector.y; });
joystick.on("end", ()=>{ joyX=0; joyY=0; });

const config = { attackRange:5, playerAttackDamage:20 };

const enemies = [], items = [], itemMeshes = [];
let portalMesh=null, portalActive=false, hasKey=false;

// Carga del mapa
BABYLON.SceneLoader.Append("", "mapa.glb", scene, ()=>{
  scene.meshes.forEach(m=>m.checkCollisions=true);
  camera.position = new BABYLON.Vector3(1,1,-5);
  initEntities();
});

function initEntities(){
  [{x:2,z:2},{x:-3,z:1},{x:5,z:-4}].forEach(e=>enemies.push(createEnemy(e.x,e.z)));
  const texH = new BABYLON.StandardMaterial("",scene);
  texH.diffuseTexture = new BABYLON.Texture("https://i.ibb.co/Xr1rftKg/1b452991-913b-4dbe-8f25-43f7108d1d70.png",scene);
  createItem(1,0,"health",texH);
  const texK = new BABYLON.StandardMaterial("",scene);
  texK.diffuseTexture = new BABYLON.Texture("https://i.ibb.co/HpKK2xwJ/1000012289-removebg-preview.png",scene);
  createItem(-1,3,"key",texK);
  portalMesh = BABYLON.MeshBuilder.CreateCylinder("portal",{height:0.1,diameter:1.5},scene);
  portalMesh.position = new BABYLON.Vector3(4,0.05,4);
  const pMat = new BABYLON.StandardMaterial("",scene);
  pMat.emissiveColor = new BABYLON.Color3(0.5,0,1);pMat.alpha=0.7;
  portalMesh.material = pMat;
}

function createEnemy(x,z){
  const c={mesh:null,health:50};
  BABYLON.SceneLoader.ImportMeshAsync(null,"","bat.glb",scene).then(r=>{
    const m=r.meshes[0];
    m.position=new BABYLON.Vector3(x,1.8,z);
    m.scaling=new BABYLON.Vector3(0.07,0.07,0.07);
    m.checkCollisions=true;
    c.mesh=m;
  });
  return c;
}

function createItem(x,z,type,mat){
  const m=BABYLON.MeshBuilder.CreatePlane(type,{width:0.3,height:0.3},scene);
  m.billboardMode=BABYLON.Mesh.BILLBOARDMODE_ALL;
  m.position=new BABYLON.Vector3(x,0.5,z);
  m.material=mat;
  const lt=new BABYLON.PointLight("",m.position,scene);
  items.push({x,z,type});
  itemMeshes.push({mesh:m,light:lt,data:{x,z,type}});
}

function checkItemCollisions(){
  for(let i=itemMeshes.length-1;i>=0;i--){
    const obj=itemMeshes[i];
    const dist=BABYLON.Vector3.Distance(camera.position,obj.mesh.position);
    if(dist<1){
      collectItem(obj.data);
      items.splice(items.findIndex(it=>it.x===obj.data.x&&it.z===obj.data.z&&it.type===obj.data.type),1);
      obj.mesh.dispose(); obj.light.dispose(); itemMeshes.splice(i,1);
    }
  }
}

function collectItem(item){
  if(item.type==="health"){
    vidaJugador=Math.min(vidaJugador+25,100);
    updateHealthBar(); showPickup("+25 Salud");
  } else if(item.type==="key"){
    hasKey=true; portalActive=true;
    portalMesh.material.emissiveColor=new BABYLON.Color3(0.8,0.2,1);
    portalMesh.material.alpha=0.8;
    showPickup("Llave obtenida");
  }
}

function playerAttack() {
      // Lanzar un rayo en dirección donde mira la cámara
      const ray = new BABYLON.Ray(
        camera.position, 
        camera.getTarget().subtract(camera.position).normalize(), 
        config.attackRange
      );
      
      // Efecto visual - flash
      const flash = new BABYLON.PointLight("attackFlash", 
        camera.position.add(camera.getTarget().subtract(camera.position).normalize()), 
        scene);
      flash.diffuse = new BABYLON.Color3(1, 0.5, 0);
      flash.range = 10;
      flash.intensity = 1;
      
      setTimeout(() => flash.dispose(), 100);
      
      // Verificar impacto
      let hitEnemy = false;
      
      for (let i = 0; i < gameState.enemies.length; i++) {
        const enemy = gameState.enemies[i];
        if (enemy.health <= 0) continue;
        
        const enemyMesh = enemyMeshes.find(e => e.data === enemy)?.mesh;
        if (!enemyMesh) continue;
        
        // Distancia al enemigo
        const dx = enemy.x - camera.position.x;
        const dz = enemy.y - camera.position.z;
        const dist = Math.sqrt(dx * dx + dz * dz);
        
        // Si está en rango
        if (dist <= config.attackRange) {
          // Calcular ángulo respecto a donde mira la cámara
          const enemyDir = new BABYLON.Vector3(dx, 0, dz).normalize();
          const cameraDirXZ = new BABYLON.Vector3(
            Math.sin(camera.rotation.y), 
            0, 
            Math.cos(camera.rotation.y)
          );
          
          const angle = BABYLON.Vector3.Dot(enemyDir, cameraDirXZ);
          
          // Si está delante y en un cono de visión
          if (angle > Math.cos(config.attackAngle)) {
            // Calcular daño
            let damage = config.playerAttackDamage;
            if (gameState.player.buffs.strength.active) {
              damage *= (1 + gameState.player.buffs.strength.value);
            }
            
            enemy.health -= damage;
            hitEnemy = true;
            
            // Efecto de impacto
            const impactPoint = new BABYLON.Vector3(enemy.x, 1, enemy.y);
            const impactParticles = new BABYLON.ParticleSystem("impactParticles", 50, scene);
            impactParticles.particleTexture = new BABYLON.Texture("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=", scene);
            impactParticles.emitter = impactPoint;
            impactParticles.color1 = new BABYLON.Color4(1, 0, 0, 1);
            impactParticles.color2 = new BABYLON.Color4(0.5, 0, 0, 1);
            impactParticles.minSize = 0.05;
            impactParticles.maxSize = 0.2;
            impactParticles.minLifeTime = 0.2;
            impactParticles.maxLifeTime = 0.6;
            impactParticles.emitRate = 300;
            impactParticles.minEmitPower = 1;
            impactParticles.maxEmitPower = 3;
            impactParticles.updateSpeed = 0.02;
            impactParticles.start();
            
            setTimeout(() => {
              impactParticles.stop();
              setTimeout(() => impactParticles.dispose(), 1000);
            }, 200);
            
            // Eliminar enemigo si muere
            if (enemy.health <= 0) {
              showPickupMessage("¡Enemigo eliminado!", "#f00");
              
              // Animación de muerte
              const duration = 30;
              const shrinkAnimation = new BABYLON.Animation(
                "enemyShrinkAnimation", "scaling", 30,
                BABYLON.Animation.ANIMATIONTYPE_VECTOR3,
                BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT
              );
              
              const sinkAnimation = new BABYLON.Animation(
                "enemySinkAnimation", "position.y", 30,
                BABYLON.Animation.ANIMATIONTYPE_FLOAT,
                BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT
              );
              
              // Keyframes de encogimiento
              const scaleKeys = [
                { frame: 0, value: enemyMesh.scaling.clone() },
                { frame: duration, value: new BABYLON.Vector3(0.1, 0.1, 0.1) }
              ];
              
              // Keyframes de hundimiento
              const positionKeys = [
                { frame: 0, value: enemyMesh.position.y },
                { frame: duration, value: -1 }
              ];
              
              shrinkAnimation.setKeys(scaleKeys);
              sinkAnimation.setKeys(positionKeys);
              
              enemyMesh.animations = [shrinkAnimation, sinkAnimation];
              const animatable = scene.beginAnimation(enemyMesh, 0, duration, false);
              
              // Eliminar enemigo cuando termine la animación
              animatable.onAnimationEnd = function() {
                const index = enemyMeshes.findIndex(e => e.data === enemy);
                if (index !== -1) {
                  enemyMeshes[index].mesh.dispose();
                  enemyMeshes.splice(index, 1);
                }
              };
            }
          }
        }
      }
      
      return hitEnemy;
    }

function castMagic(){
  const magicFlash=new BABYLON.HemisphericLight("magicFlash",camera.position,scene);
  magicFlash.diffuse=new BABYLON.Color3(0.2,0.4,1);
  magicFlash.groundColor=new BABYLON.Color3(0.1,0.2,0.5);
  magicFlash.intensity=20;
  setTimeout(()=>magicFlash.dispose(),200);

  enemies.forEach(e=>{
    if(e.mesh){
      const dx=e.mesh.position.x-camera.position.x;
      const dz=e.mesh.position.z-camera.position.z;
      const dist=Math.hypot(dx,dz);
      if(dist<=config.attackRange*1.5){
        e.health-=config.playerAttackDamage;
        if(e.health<=0) e.mesh.dispose();
      }
    }
  });
}

document.getElementById("btnAttack").onclick = playerAttack;
document.getElementById("btnMagic").onclick = castMagic;

engine.runRenderLoop(()=>{
  const f=camera.getDirection(BABYLON.Axis.Z), r=camera.getDirection(BABYLON.Axis.X);
  camera.cameraDirection = BABYLON.Vector3.Zero()
    .addInPlace(f.scale(joyY*0.1))
    .addInPlace(r.scale(joyX*0.1));

  enemies.forEach(e=>{
    if(e.mesh){
      const dir = camera.position.subtract(e.mesh.position), dist=dir.length();
      if(dist<30 && dist>1){
        e.mesh.moveWithCollisions(dir.normalize().scale(0.06));
      }
    }
  });

  checkItemCollisions();

  if(portalMesh){
    portalMesh.rotation.y += 0.01;
    if(portalActive && hasKey && BABYLON.Vector3.Distance(camera.position,portalMesh.position)<1){
      window.location.href = "nivel2.html";
    }
  }

  scene.render();
});

window.addEventListener("resize",()=>engine.resize());
</script>
</body>
</html>
